---
title: "Comparison of FROGS/MOTHUR/UPARSE/QIIME on simulated and synthetic microbial communities"
author: "Mahendra Mariadassou, GÃ©raldine Pascal"
date: "30 november 2016"
output:
  html_document:
    number_sections: yes
    theme: united
    toc: yes
    toc_float:
      collapsed: true
      smooth_scroll: true
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE, echo = FALSE}
# setwd("~/Research_Projects/Microbiota/Geraldine/")
knitr::opts_chunk$set(echo = FALSE, cache = TRUE, message = FALSE, 
                      fig.path = "Figures_20161130/Fig-english/", 
                      cache.path = "cache/english/")
```

```{r load-packages, echo = FALSE}
library(reshape2)
library(ggplot2)
library(dplyr)
library(grid)
library(gridExtra)
library(knitr)
```

```{r utility-functions, cache = FALSE}
source("utilities.R")
```

# Introduction

This is an R markdown document intended to compare the performances of FROGS, MOTHUR, UPARSE and QIIME in terms of accuracy on both simulated and synthetic microbial communities. We consider two variants of MOTHUR, UPARSE and QIIME called respectively SOP and MA. SOP correspond to Standard Operating Procedures (program guidelines) whereas MA stands for Multi-Affiliation and correspond to a multiple affiliation strategy used to propagate uncertainty when multiple equally good affiliations are found for a given OTU. This is the default strategy used in FROGS. 

Throughout, QIIME (MA) refers to QIIME with Multi-Affiliation strategy, QIIME (SOP) to the affiliation strategy suggested in QIIME SOP and QIIME to both variants: QIIME (MA) and QIIME (SOP). 

## Metrics used for comparison 

The results of FROGS, MOTHUR and UPARSE, QIIME are compared using three different metrics:   

1. **Divergence**: Bray-Curtis distance (expressed in percent) between the true taxonomic composition of the community and the one inferred by the otu-picking tool. The divergence is measured at all taxonomic ranks from Phylum to either Genus (utax) or Species (Silva).  
2. **FN**: Number of false negative taxa (*i.e.* present in the original bacterial community but not discovered by the otu picking method);
3. **FP**: Number of false positive taxa (*i.e.* discovered by the otu picking method but not present in the original bacterial community)  

## Experimental design

The experimental design differed for the simulated communities (for which a full-factorial design was used) and the synthetic communities. 

### Simulated bacterial communities

The simulated communities were built according to the following design:  

1. **Databank**: Biobank from which taxa were drawn to construct theoretical communities, either Silva (*silva*) or Utax (*utax*).  
2. **Number of OTUs**: 20, 100, 200, 500 and 1000;  
3. **Abundance distribution**: abundances of OTUs were either uniform (*uniform*) or sampled from a power distribution (*power_law*);  
4. **Dataset**: Theoretical communities. Each dataset (5 for each combinaison of abundance distribution and number of OTUs) correspond to a unique **ideal** bacterial community specified by its own taxa set and corresponding vector of relative abundances.  
5. **Set Number**: Biological replicates (10 for each dataset), *i.e.* communities created by sampling organisms with replacement in the theoretical communities.  
6. **Amplicon**: variable region of the 16S rRNA used to produce the ampicon sequences, either the V3-V4 (*V3V4*) variable region or the V4-V4 (*V4V4*) variable region  

This resulted in a total of 2 databanks $\times$ 5 community sizes $\times$ 2 abundance distribution $\times$ 10 theoretical communities $\times$ 10 replicates for each theoretical community $\times$ 2 amplicons $=$ `r 2*5*2*5*10*2` samples (`r 5*2*5*10*2` per databank). 

```{r experimental-design-silva, eval = FALSE}
read.table("silva.tsv", sep = "\t", header = TRUE) %>% group_by(databank, nb_OTU, amplicon, abundance_law, dataset) %>% summarize(count = n()/4) %>% kable()
read.table("utax.tsv", sep = "\t", header = TRUE) %>% group_by(databank, nb_OTU, amplicon, abundance_law, dataset) %>% summarize(count = n()/7) %>% kable()
```

### Synthetic communities

The experimental design used for the synthetic community was sligthly different:
```{r experimental-design-real}
read.table("reel.tsv", sep = "\t", header = TRUE) %>% group_by(nb_OTU, amplicon, abundance_law) %>% summarize(count = n()/4) %>% kable()
```

Three samples corresponding to communities of size 20 with abundance distribution *even* were used to compare the amplicon *V3V4*, *V4V4* and *V4V5* (1 per amplicon). 8 samples corresponding to communities of size 20 and amplicon *V3V4* were used to compared abundance distribution *even* and *staggered* (4 per distribution) and finally, 19 samples (community size 4, amplicon *V3V4* and distribution *even*) were used to compare the accuracy of the different otu picking methods. 


# Statistical analysis of the results: Material and Methods

For each of the three metrics (divergence, FN and FP) we performed two-sided paired test, either parametric (paired t-test) or non-parametric (signed rank test, also known as paired mann-whitney test) to assess the difference in accuracy between FROGS and each of the competitors. 

The tests were peformed at the theoretical community levels (*dataset*) using biological replicates (*set_number*) as replicates. We chose to compare the methods at this level because it the finest one for which we have replication. Pooling different theoretical communities and/or abundance distributions to compare the method at higher levels (*e.g* community size $\times$ amplicon) will blur the signal as a method may be  outclass the others for even abundances but perform worse on different abundance disrtibutions. 

For each theoretical community, we declared FROGS better (resp. worse) than its competitor when the test was significant at the 0.05 level and FROGS had a lower (resp. higher) metric than its competitor. When the test was not significant, the methods were declared tied. Finally, we aggregated the results to count for each condition (community size $\times$ abundance distribution $\times$ amplicon) the number of theoretical communities favoring one or none of the methods. 

Before presenting the statistical analysis per se, we first present the results graphically for each of the databank and for the synthetic communities. 

[//]: # (Import and format data)

```{r data-format, eval = FALSE}
data$nb_OTU <- as.numeric(sub("sp", "", data$nb_OTU))
if ("OTU.lost" %in% names(data)) {
data <- data %>% mutate(OTU.lost = -OTU.lost) %>%
  melt(id.vars = c("databank", "nb_OTU", "dataset", 
                   "set_number", "amplicon", "abundance_law", "method"), 
       value.name = "divergence", 
       variable.name = "rank")
  levels(data$rank) <- c(levels(data$rank)[1:(length(levels(data$rank))-2)], "FN", "FP")
} else {
data <- data %>% 
  melt(id.vars = c("databank", "nb_OTU", "dataset", 
                   "set_number", "amplicon", "abundance_law", "method"), 
       value.name = "divergence", 
       variable.name = "rank")
  
}
data.2 <- data %>% dcast(databank + nb_OTU + dataset + set_number + amplicon + abundance_law + rank ~ method, value.var = "divergence", fun.aggregate = mean) %>% 
  melt(id.vars = c("databank", "nb_OTU", "dataset", 
                   "set_number", "amplicon", "abundance_law", "rank", "frogs"), 
       value.name = "divergence", 
       variable.name = "method")
```

```{r split-divergence-and-otu, eval = FALSE}
data.otus <- filter(data, (rank %in% c("FP", "FN"))) %>% mutate(error_type = rank)
data <- filter(data, !(rank %in% c("FP", "FN"))) %>% mutate(rank = factor(rank))
data.otus.2 <- filter(data.2, (rank %in% c("FP", "FN"))) %>% mutate(error_type = rank)
data.2 <- filter(data.2, !(rank %in% c("FP", "FN"))) %>% mutate(rank = factor(rank))
```

```{r plot-data-raw, message=FALSE, warning=FALSE, eval = FALSE}
p <- ggplot(data = data.2, mapping = aes(x = frogs, y = divergence, color = abundance_law, shape = amplicon)) + facet_grid(rank ~ nb_OTU) + geom_abline(slope = 1, intercept = 0) + theme_bw() + scale_x_log10() + scale_y_log10() + xlab("divergence frogs")
plot.list <- generate_pointplot(p, data = data.2, vbl="method", ylab = "Divergence competitor")
grid_arrange_shared_legend(plot.list, ncol = 2)
```

```{r plot-data-raw-boxplot, warning=FALSE, eval = FALSE}
p <- ggplot(data.2, mapping = aes(x = interaction(amplicon, abundance_law), y = frogs - divergence, fill = method, color = method)) + facet_grid(rank ~ nb_OTU, scales = "fixed") + geom_boxplot(outlier.size = 0.8) + geom_boxplot(aes(color = NULL), outlier.color = "transparent") + theme_bw() + scale_y_continuous(limits = c(-15, 3)) + theme(axis.text.x = element_text(angle = 90)) + scale_fill_manual(values = manual.palette) + scale_color_manual(values = manual.palette, guide = "none") + xlab(NULL) + ylab("FROGS excess divergence") + geom_hline(yintercept = 0, col = "grey60")
plot(p)
```

```{r plot-frogs-only-divergence, warning=FALSE, eval = FALSE}
p <- ggplot(filter(data, method == "frogs"), mapping = aes(x = rank, y = divergence, fill = method)) + facet_grid(abundance_law + amplicon ~ nb_OTU, scales = "fixed") + geom_boxplot() + theme_bw() + scale_y_continuous(limits = c(0, 16)) + theme(axis.text.x = element_text(angle = 90)) + scale_fill_manual(values = manual.palette) + xlab(NULL) + ggtitle("Divergence")
plot(p)
```

```{r plot-fp-fn-boxplot, warning=FALSE, message = FALSE, eval = FALSE}
p <- ggplot(data.otus, mapping = aes(x = method, fill = method, y = divergence, alpha = amplicon)) + facet_grid(nb_OTU ~ abundance_law, scales = "free_y") + theme_bw() + scale_y_continuous(limits = c(0, NA)) + theme(axis.text.x = element_text(angle = 90)) + scale_fill_manual(values = manual.palette) + scale_color_manual(values = manual.palette) + scale_alpha_discrete(guide = guide_legend(override.aes = list(fill = "grey10")), range = c(0.2, 0.6)) + ylab(NULL)
p.fn <- p + geom_boxplot(data = filter(data.otus, error_type == "FN")) + ggtitle("False Negative OTUs")
p.fp <- p + geom_boxplot(data = filter(data.otus, error_type == "FP")) + ggtitle("False Positive OTUs")
grid_arrange_shared_legend(p.fp, p.fn, ncol = 2)
```

```{r plot-fp-fn-boxplot-no-mothur, warning=FALSE, message = FALSE, eval = FALSE}
p <- ggplot(data.otus, mapping = aes(x = method, fill = method, y = divergence, alpha = amplicon)) + facet_grid(nb_OTU ~ abundance_law, scales = "free_y") + theme_bw() + scale_y_continuous(limits = c(0, NA)) + theme(axis.text.x = element_text(angle = 90)) + scale_fill_manual(values = manual.palette) + scale_color_manual(values = manual.palette) + scale_alpha_discrete(guide = guide_legend(override.aes = list(fill = "grey10")), range = c(0.2, 0.6)) + ylab(NULL)
excluded.methods <- c("mothur", "mothur_sop", "qiime", "qiime_sop", "mothur (Mult Aff)", "mothur (SOP)", "qiime (Mult Aff)", "qiime (SOP)")
p.fn <- p + geom_boxplot(data = filter(data.otus, error_type == "FN", !(method %in% excluded.methods))) + ggtitle("False Negative OTUs")
p.fp <- p + geom_boxplot(data = filter(data.otus, error_type == "FP", !(method %in% excluded.methods))) + ggtitle("False Positive OTUs")
grid_arrange_shared_legend(p.fp, p.fn, ncol = 2)
```

```{r batch-t-test, eval = FALSE}
data.t.test <- data.2 %>% group_by(databank, nb_OTU, dataset, amplicon, abundance_law, rank, method) %>% 
  summarize(pval = t.test(frogs, divergence, paired = TRUE)$p.value, 
            measure = t.test(frogs, divergence, paired = TRUE)$estimate) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r batch-t-test-plot, eval = FALSE}
p <- ggplot(mapping = aes(x = rank, fill = best)) + facet_grid(abundance_law + amplicon ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90))
plot.list <- generate_barplot(p, data = data.t.test, vbl = "method", ylab = "Number of communities")
grid_arrange_shared_legend(plot.list, ncol = 2)
```

```{r batch-wilcox-test-np, eval = FALSE}
data.wilcox.test <- data.2 %>% group_by(databank, nb_OTU, dataset, amplicon, abundance_law, rank, method) %>% 
  summarize(pval = wilcox.test(frogs, divergence, paired = TRUE)$p.value, 
            measure = wilcox.test(frogs, divergence, paired = TRUE, conf.int = TRUE)$estimate) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r batch-wilcox-test-plot, eval = FALSE}
p <- ggplot(mapping = aes(x = rank, fill = best)) + facet_grid(abundance_law + amplicon ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90))
plot.list <- generate_barplot(p, data = data.wilcox.test, vbl = "method", ylab = "Number of communities")
grid_arrange_shared_legend(plot.list, ncol = 2)
```

```{r batch-t-test-otus, eval = FALSE}
data.otus.t.test <- data.otus.2 %>% group_by(databank, nb_OTU, dataset, amplicon, abundance_law, error_type, method) %>% 
  summarize(pval = my.paired.t.test(frogs, divergence)$p.value, 
            measure = my.paired.t.test(frogs, divergence)$estimate) %>% 
  mutate(best = ifelse(measure > 0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r batch-t-test-otus-plot, eval = FALSE}
p <- ggplot(mapping = aes(x = error_type, fill = best)) + facet_grid(abundance_law + amplicon ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90)) + xlab("Error Type")
plot.list <- generate_barplot(p, data = data.otus.t.test, vbl = "method", ylab = "Number of communities")
grid_arrange_shared_legend(plot.list, ncol = 2)
```

```{r batch-wilcox-test-np-otus, warning=FALSE, eval = FALSE}
data.otus.wilcox.test <- data.otus.2 %>% group_by(databank, nb_OTU, dataset, amplicon, abundance_law, error_type, method) %>% 
  summarize(pval = my.paired.wilcox.test(frogs, divergence)$p.value, 
            measure = sum(sign(frogs - divergence) * rank(abs(frogs - divergence)))) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r batch-wilcox-test-plot-otus, eval = FALSE}
p <- ggplot(mapping = aes(x = error_type, fill = best)) + facet_grid(abundance_law + amplicon ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90)) + xlab("Error Type")
plot.list <- generate_barplot(p, data = data.otus.wilcox.test, vbl = "method", ylab = "Number of communities")
grid_arrange_shared_legend(plot.list, ncol = 2)
```

[//]: # (End of generic code)

# Utax databank


```{r utax-data-import}
data <- read.table("utax.tsv", sep = "\t", header = TRUE)
```

```{r utax-data-format, ref.label="data-format"}
```

```{r utax-change-method-order}
data <- data %>% mutate(method = factor(method, levels = c("frogs", "uparse_sop", "uparse", "mothur_sop", "mothur", "qiime_sop", "qiime"), 
                                            labels = c("frogs", "uparse (SOP)", "uparse (MA)", "mothur (SOP)", "mothur (MA)", "qiime (SOP)", "qiime (MA)")))
data.2 <- data.2 %>% mutate(method = factor(method, levels = c("uparse_sop", "uparse", "mothur_sop", "mothur", "qiime_sop", "qiime"), 
                                            labels = c("uparse (SOP)", "uparse (MA)", "mothur (SOP)", "mothur (MA)", "qiime (SOP)", "qiime (MA)")))
```

```{r utax-split-divergence-and-otu, ref.label="split-divergence-and-otu"}
```

## Vizualisation 

### Divergence 

The comparisons of divergence at the sample level in the scatterplots shows that on average, FROGS has comparable but better performances than MOTHUR, UPARSE and QIIME (SOP): most samples end up in the upper left corner (corresponding to the region "divergence FROGS < divergence competitor") but no too far away from the first diagonal (grey line). It also has comparable performances to QIIME (MA) but in certain conditions, samples are not mostly contained in the upper left half of the graph, meaning that QIIME (MA) outperforms FROGS for those parameter values. 


```{r utax-plot-data-raw, fig.width=10, fig.height=15, message=FALSE, warning=FALSE, ref.label="plot-data-raw"}
```

A more traditional representation using boxplot of the excess divergence of FROGS, with samples from all theoretical communities pooled together, confirms the results: FROGS has similar (compared to UPARSE) or lower (compared to MOTHUR) divergence for the vast majority of samples. Note that the y-range was reduced from $[-85, 31]$ to $[-15, 3]$ in order to exclude outliers (4% of outliers with excess divergence < -15 and 0.02% with excess divergence > 3) and zoom in on the boxplots. As expected, all methods perform quite similarly up to the order level and the main differences appear at the *Family* and *Genus* levels, where MOTHUR and QIIME (SOP) produces much larger divergences than competing methods. The only configuration where FROGS is consistently outperformed is complex communities (number of species > 200) with uniform abundances and sequenced on the V4V4 region. In that configuration, FROGS is outperformed by QIIME (MA). 

```{r utax-plot-data-raw-boxplot, fig.width=10, fig.height=7, warning=FALSE, ref.label="plot-data-raw-boxplot"}
```

Finally a focus on the accuracy of FROGS alone shows that divergence levels vary between 0 and 10% and as expected, is higher for fine classification (Genus) than for coarse ones (Phylum). Unsurprisingly, the V3V4 amplicon gives less distorded view of communities than the V4V4. Overall, FROGS recover community compositions very well expect at the genus level for complex communities (size > 200), with uniform abundances and sequenced using the V4V4 region. 
```{r utax-plot-frogs-only-divergence, fig.width=10, fig.height=7, warning=FALSE, ref.label="plot-frogs-only-divergence"}
```

### False Positive and False Negative OTUs

We repeat the graphical exploration of the resutls with False Positive and False Negative OTUs. A first representation shows that use of the V3V4 amplicon leads to more false postive and less false negative than the V4V4. The graphics also highlight the gigantic number of false positive inferred by mothur (up to 20 times more than the real community size).  

```{r utax-plot-fp-fn-boxplot, fig.width=10, fig.height=8, warning=FALSE, message = FALSE, ref.label="plot-fp-fn-boxplot"}
```

A focus on FROGS and UPARSE leads to similar patterns: FROGS always produces less false negatives than UPARSE but produces a bit more false positive under power law abundance distribution and a bit less under uniform abundance distribution. 

The lower number of false positive under power law abundances could be due to the abundance based filters used in UPARSE. 

```{r utax-plot-fp-fn-boxplot-no-mothur, fig.width=10, fig.height=8, warning=FALSE, message = FALSE, ref.label="plot-fp-fn-boxplot-no-mothur"}
```

## Statistical Analysis

### Divergence

We present the results of the paired tests, either parametric (t-test, top) or non-parametric (signed rank test, bottom). Both tests show that FROGS perform as well or better as UPARSE and MOTHUR in most conditions. The only condition in which FROGS does worse than UPARSE is small community size (20). It also does better than QIIME (SOP) in all settings, and than QIIME (MA) in most settings with the notable exception of large communities (size > 200) with uniform abundance studied using the V4V4 region. 

The real strength of FROGS lies in its ability ot give a more accurate view of large communities (size > 200) at fine scales (Species or Genus level). 

#### Paired t-test

```{r utax-batch-t-test, ref.label="batch-t-test"}
```

```{r utax-batch-t-test-plot, fig.width=10, fig.height=15, ref.label="batch-t-test-plot"}
```

#### Signed rank test

```{r utax-batch-wilcox-test-np, ref.label="batch-wilcox-test-np"}
```

```{r utax-batch-wilcox-test-plot, fig.width=10, fig.height=15, ref.label="batch-wilcox-test-plot"}
```

### Conditions where QIIME (MA) outperforms FROGS

A focus on the performance of QIIME (MA) reveals that QIIME (MA) indeed performs better than FROGS with uniform distribution when using the V4V4 amplicon region. However and although significant, the differences are small in that case: less than 2 percentage points in all cases and most marked at the Genus level where the divergences of both FROGS and QIIME (MA) are quite high.  

```{r qiime-better-frogs, fig.width=10, fig.height=6, warning=FALSE}
p1 <- ggplot(data.2 %>% filter(method == "qiime (MA)"), 
            mapping = aes(x = rank, y = (frogs - divergence), fill = method)) + 
  facet_grid(amplicon + abundance_law ~ nb_OTU, scales = "free_y") + 
  theme_bw() + scale_y_continuous() + theme(axis.text.x = element_text(angle = 90)) + 
  scale_fill_manual(values = manual.palette, guide = guide_legend(byrow = TRUE)) + scale_color_manual(values = manual.palette, guide = "none") + 
  xlab("Number of OTUs") + ylab("Frogs excess divergence") + 
  geom_boxplot(aes(group = rank), outlier.size = 0.8) + geom_hline(aes(yintercept = 0), color = "gray65")
p2 <- ggplot(data %>% filter(method %in% c("frogs", "qiime (MA)")), 
            mapping = aes(x = rank, y = (divergence), fill = method)) + 
  facet_grid(amplicon + abundance_law ~ nb_OTU, scales = "free_y") + 
  theme_bw() + scale_y_continuous(limits = c(0, 10), breaks = c(0, 3, 6, 9)) + theme(axis.text.x = element_text(angle = 90)) + 
  scale_fill_manual(values = manual.palette, guide = guide_legend(byrow = TRUE)) + scale_color_manual(values = manual.palette, guide = "none") + 
  xlab("Number of OTUs") + ylab("Divergence") + 
  geom_boxplot(aes(group = interaction(rank, method), color = method), outlier.size = 0.8) + 
  geom_boxplot(aes(group = interaction(rank, method)), outlier.color = "transparent")
## grid_arrange_shared_legend(p2, p1, ncol = 2)
grid.arrange(p1 + theme(legend.position = "bottom"), p2 + theme(legend.position = "bottom"), ncol = 2, widths = c(0.45, 0.55))
```

### False Positive and False Negative OTUs

The same paired test as in the previous section reveal that FROGS strictly outperforms MOTHUR in terms of both FP and FN taxas. It also produces less FN than UPARSE. Additionnally, it produces less FP than UPARSE for uniform distributions and more power law ones. Overall, FROGS produces less FP and less FN than either of UPARSE and MOTHUR for high community sizes (>200 for uniform distributions, >1000 for power law distributions). It also produces less FP and FN than QIIME under power law distribution and less FP but more FN than QIIME under uniform distribution. 

#### Paired t-test

```{r utax-batch-t-test-otus, ref.label="batch-t-test-otus"}
```

```{r utax-batch-t-test-otus-plot, fig.width=10, fig.height=15, ref.label="batch-t-test-otus-plot"}
```

#### Signed rank test

```{r utax-batch-wilcox-test-np-otus, warning=FALSE, ref.label="batch-wilcox-test-np-otus"}
```

```{r utax-batch-wilcox-test-plot-otus, fig.width=10, , fig.height=15, ref.label="batch-wilcox-test-plot-otus"}
```


# Silva databank


```{r silva-data-import}
data <- read.table("silva.tsv", sep = "\t", header = TRUE)
```

```{r silva-data-format, ref.label="data-format"}
```

```{r silva-change-method-order}
data <- data %>% mutate(method = factor(method, levels = c("frogs", "uparse", "mothur", "qiime"), 
                                        labels = c("frogs", "uparse (MA)", "mothur (MA)", "qiime (MA)")))
data.2 <- data.2 %>% mutate(method = factor(method, levels = c("uparse", "mothur", "qiime"), 
                                            labels = c("uparse (MA)", "mothur (MA)", "qiime (MA)")))
```

```{r silva-split-divergence-and-otu, ref.label="split-divergence-and-otu"}
```

## Vizualisation 

### Divergence 

The comparisons of divergence at the sample level in the scatterplots shows that on average, FROGS has comparable but better performances than MOTHUR (MA), UPARSE (MA) and QIIME (MA): most samples end up in the upper left corner (corresponding to the region "divergence FROGS < divergence competitor") but no too far away from the first diagonal (grey line). 


```{r silva-plot-data-raw, fig.width=12, fig.height=10, message=FALSE, warning=FALSE, ref.label="plot-data-raw"}
```

A more traditional representation using boxplot of the excess divergence of FROGS, with samples from all theoretical communities pooled together, confirms the results: FROGS has similar (compared to UPARSE (MA) and QIIME (MA)) or lower (compared to MOTHUR (MA)) divergence for the vast majority of samples. Note that the y-range was reduced from $[-51, 41]$ to $[-15, 3]$ in order to exclude from outliers (1% of communities with low FROGS but very high MOTHUR (MA) divergence or high FROGS but low QIIME (MA) divergences) and zoom in on the boxplots. The only configuration where FROGS is consistently outperformed is complex communities (number of species > 200) with uniform abundances and sequenced on the V4V4 region. In that configuration, FROGS is outperformed by QIIME (MA). 

```{r silva-plot-data-raw-boxplot, fig.width=10, fig.height=7, warning=FALSE, ref.label="plot-data-raw-boxplot"}
```

Finally a focus on the accuracy of FROGS alone shows that divergence levels vary mostly between 0 and 15% and as expected, are higher for finer classifications (Species) than for coarse ones (Phylum). Unsurprisingly, the V3V4 amplicon gives less distorded view of communities than the V4V4. 
```{r silva-plot-frogs-only-divergence, fig.width=10, fig.height=7, warning=FALSE, ref.label="plot-frogs-only-divergence"}
```

### False Positive and False Negative OTUs

We repeat the graphical exploration of the resutls with False Positive and False Negative OTUs. A first representation shows that use of the V3V4 amplicon leads to more false postive and less false negative than the V4V4. The graphics also highlight the gigantic number of false positives inferred by MOTHUR and QIIME (up to 20 times more than the real community size).  

```{r silva-plot-fp-fn-boxplot, fig.width=10, fig.height=8, warning=FALSE, message = FALSE, ref.label="plot-fp-fn-boxplot"}
```

A focus on FROGS and UPARSE (MA) leads to similar patterns: FROGS always produces less false negatives than UPARSE (MA) but produces a bit more false positive under power law abundance distribution and a bit less under uniform abundance distribution. 

The lower number of false positive in under power law abundances could be due to the abundance based filters used in UPARSE (MA). 

```{r silva-plot-fp-fn-boxplot-no-mothur, fig.width=10, fig.height=8, warning=FALSE, message = FALSE, ref.label="plot-fp-fn-boxplot-no-mothur"}
```

## Statistical Analysis

### Divergence

We present the results of the paired tests, either parametric (t-test, top) or non-parametric (signed rank test, bottom). Both tests show that FROGS perform as well or better as UPARSE (MA) and MOTHUR (MA) in most conditions. The only condition in which FROGS does worse than UPARSE (MA) is small community size (20). It also does better than QIIME (MA) in most settings, with the exception of large communities (size > 200) with uniform abundance studied using the V4V4 region. 

The real strength of FROGS lies in its ability ot give a more accurate view of large communities (size > 200) at fine scales (Species or Genus level). 

#### Paired t-test

```{r silva-batch-t-test, ref.label="batch-t-test"}
```

```{r silva-batch-t-test-plot, fig.width=10, fig.height=10, ref.label="batch-t-test-plot"}
```

#### Signed rank test

```{r silva-batch-wilcox-test-np, ref.label="batch-wilcox-test-np"}
```

```{r silva-batch-wilcox-test-plot, fig.width=10, fig.height=10, ref.label="batch-wilcox-test-plot"}
```

### False Positive and False Negative OTUs

The same paired test as in the previous section reveal that FROGS strictly outperforms MOTHUR (MA) in terms of both FP and FN taxas. It also produces less FN than UPARSE (MA) and less FP than QIIME (MA). Additionnally, it produces less FP than UPARSE (MA) for uniform distributions and more for power law ones. 

Overall, FROGS produces less FP and less FN than either of UPARSE (MA) and MOTHUR (MA) for high community sizes (>200 for uniform distributions, >1000 for power law distributions) and less FP than QIIME (MA) at all sizes. 

#### Paired t-test

```{r silva-batch-t-test-otus, ref.label="batch-t-test-otus"}
```

```{r silva-batch-t-test-otus-plot, fig.width=10, fig.height=10, ref.label="batch-t-test-otus-plot"}
```

#### Signed rank test

```{r silva-batch-wilcox-test-np-otus, warning=FALSE, ref.label="batch-wilcox-test-np-otus"}
```

```{r silva-batch-wilcox-test-plot-otus, fig.width=10, fig.height=10, ref.label="batch-wilcox-test-plot-otus"}
```

# Synthetic Communities 

Due to the different design used for synthetic communities, we're going to perform focused comparisons of the samples. 

```{r real-data-import}
data <- read.table("reel.tsv", sep = "\t", header = TRUE)
```

```{r real-data-format, ref.label="data-format"}
```

```{r real-change-method-order}
data <- data %>% mutate(method = factor(method, levels = c("frogs", "uparse", "mothur", "qiime"), 
                                        labels = c("frogs", "uparse (MA)", "mothur (MA)", "qiime (MA)")))
data.2 <- data.2 %>% mutate(method = factor(method, levels = c("uparse", "mothur", "qiime"), 
                                            labels = c("uparse (MA)", "mothur (MA)", "qiime (MA)")))
```

## Amplicon Effect 

We study the amplicon effect on the even community with 20 species as it is the only one for which different amplicons were used. We represent the trends observed at different taxonomic levels. UPARSE (MA) seems to do better than FROGS and MOTHUR (MA) but there is only one sample per amplicon so we can't assess the significance of that trend. 

Note that all methods have high divergences compared to simulated datasets. This may reflect experimental limitations (sequencing and amplification bias, copy number variations, etc) rather than intrinsic complexity of the synthetic community and/or differences between the methods. 

```{r amplicon-effect-paired-plot}
p <- ggplot(filter(data, abundance_law == "even" & set_number == "set1"), aes(x = method, y = divergence)) + geom_point(aes(color = method)) + geom_line(aes(group = rank, alpha = rank)) + facet_grid(~amplicon) + scale_color_manual(values = manual.palette) + scale_y_continuous(lim = c(0, NA)) + theme_bw()
plot(p)
```

## Abundance Distribution Effect

We study the abundance distribution effect on the community with 20 species sequenced with the V3V4 amplicon region. FROGS is better than MOTHUR (MA), UPARSE (MA) and QIIME (MA) on the staggered community and worse on the even one... 

```{r distribution-effect-paired-plot, fig.width = 8, fig.height = 4.5}
p <- ggplot(filter(data.2, amplicon == "V3V4" & nb_OTU == 20), aes(x = method, y = frogs - divergence)) + geom_point() + geom_boxplot(aes(fill = method)) + facet_grid(abundance_law ~ rank) + scale_color_manual(name = "Competitor", values = manual.palette) + scale_fill_manual(name = "Competitor", values = manual.palette) + theme_bw() + geom_hline(yintercept = 0, col = "grey60") + ylab("Frogs excess divergence") + theme(axis.text.x = element_text(angle = 90))
plot(p)
```

Although the base divergence is not very satisfying on either distribution. 
```{r distribution-effect-boxplot, fig.width = 8, fig.height = 4.5}
p <- ggplot(filter(data, amplicon == "V3V4", nb_OTU == 20, method == "frogs"), aes(x = method, y = divergence)) + geom_point() + geom_boxplot(aes(fill = method)) + facet_grid(abundance_law ~ rank) + scale_color_manual(values = manual.palette) + scale_fill_manual(values = manual.palette) + theme_bw() + ylab("Frogs divergence") + theme(axis.text.x = element_text(angle = 90))
plot(p)
```

As we have 4 replicates for this community, we can compare all methods using a paired t-test (there are not enough replicates for the non parametric signed rank test to reach significance). The statistical analysis confirm that FROGS outperforms MOTHUR (MA), UPARSE (MA) and QIIME (MA) on communities with staggered abundances but does worse on communities with even abundances. 

```{r real-distribution-t-test}
data.t.test <- data.2 %>% filter(amplicon == "V3V4", nb_OTU == 20) %>% 
  group_by(databank, nb_OTU, dataset, amplicon, abundance_law, rank, method) %>% 
  summarize(pval = t.test(frogs, divergence, paired = TRUE)$p.value, 
            measure = t.test(frogs, divergence, paired = TRUE)$estimate) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r real-distribution-t-test-plot, fig.width=8, fig.height=8}
p <- ggplot(mapping = aes(x = rank, fill = best)) + facet_grid(abundance_law ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90))
plot.list <- generate_barplot(p, data = data.t.test, vbl = "method", ylab = "Number of communities")
grid_arrange_shared_legend(plot.list, ncol = 2)
```

## Comparison on a Toy Community

Finally, we compare the three methods on a toy community with 20 species and even abundances. We have  10 replicates for this community, enough to use either the signed rank test and the paired t-test. Once again FROGS base divergence level is not fantastic
```{r real-method-effect-4-species-boxplot, fig.width = 8, fig.height = 4}
p <- ggplot(filter(data, nb_OTU == 4, method == "frogs"), aes(x = method, y = divergence)) + geom_point(aes(color = method)) + geom_boxplot(aes(fill = method)) + facet_grid(~rank) + scale_color_manual(values = manual.palette) + scale_fill_manual(values = manual.palette) + scale_y_continuous(lim = c(0, NA)) + theme_bw()
plot(p)
```

but in line with divergences obtained by competitors
```{r real-method-effect-4-species-paired-plot, fig.width = 8, fig.height = 4}
p <- ggplot(filter(data.2, nb_OTU == 4), aes(x = method, y = frogs - divergence)) + geom_point() + geom_boxplot(aes(fill = method)) + facet_grid(~ rank) + scale_color_manual(name = "Competitor", values = manual.palette) + scale_fill_manual(name = "Competitor", values = manual.palette) + theme_bw() + geom_hline(yintercept = 0, col = "grey60") + ylab("Frogs excess divergence")
plot(p)
```

The statistical analyses confirms the graphical diagnostic of the boxplot: FROGS is generally better than MOTHUR (MA) and QIIME (MA) and tied with UPARSE (MA), except at the Genus rank where it outperforms all three. It also performs worse than UPARSE (MA) at the Phylum rank (for the paired t-test)

## Paired t-test on divergence

```{r real-method-t-test-4-species, fig.width=8, fig.height=8}
data.t.test <- data.2 %>% filter(nb_OTU == 4) %>% 
  group_by(databank, nb_OTU, dataset, amplicon, abundance_law, rank, method) %>% 
  summarize(pval = t.test(frogs, divergence, paired = TRUE)$p.value, 
            measure = t.test(frogs, divergence, paired = TRUE)$estimate) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r real-method-t-test-4-species-plot, fig.width=8, fig.height=8}
p <- ggplot(mapping = aes(x = rank, fill = best)) + facet_grid(abundance_law ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90))
plot.list <- generate_barplot(p, data = data.t.test, vbl = "method", ylab = "Number of communities")
grid_arrange_shared_legend(plot.list, ncol = 2)
```

## Signed rank test on divergence

```{r real-method-wilcox-test-4-species}
data.wilcox.test <- data.2 %>% filter(nb_OTU == 4) %>% 
  group_by(databank, nb_OTU, dataset, amplicon, abundance_law, rank, method) %>% 
  summarize(pval = wilcox.test(frogs, divergence, paired = TRUE)$p.value, 
            measure = wilcox.test(frogs, divergence, paired = TRUE, conf.int = TRUE)$estimate) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```


```{r real-method-wilcox-test-4-species-plot, fig.width=8, fig.height=8}
p <- ggplot(mapping = aes(x = rank, fill = best)) + facet_grid(abundance_law ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90))
plot.list <- generate_barplot(p, data = data.wilcox.test, vbl = "method", ylab = "Number of communities")
grid_arrange_shared_legend(plot.list, ncol = 2)
```
