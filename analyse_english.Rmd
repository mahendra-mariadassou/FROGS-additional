---
title: "Comparison of FROGS/MOTHUR/UPARSE/QIIME on simulated and synthetic microbial communities"
author: "Mahendra Mariadassou, GÃ©raldine Pascal"
date: "30 november 2016"
output:
  html_document:
    number_sections: yes
    theme: united
    toc: yes
    toc_float:
      collapsed: true
      smooth_scroll: true
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE, echo = FALSE}
# setwd("~/Research_Projects/Microbiota/Geraldine/")
knitr::opts_chunk$set(echo = FALSE, cache = TRUE, message = FALSE, 
                      fig.path = "Figures_20161130/Fig-english/", 
                      cache.path = "cache/english/")
```

```{r load-packages, echo = FALSE, cache = FALSE}
library(reshape2)
library(ggplot2)
library(dplyr)
library(grid)
library(gridExtra)
library(knitr)
```

```{r utility-functions, cache = FALSE}
source("utilities.R")
```

# Introduction

This is an R markdown document intended to compare the performances of FROGS, MOTHUR, UPARSE and QIIME in terms of accuracy on both simulated and synthetic microbial communities. We consider two variants of MOTHUR, UPARSE and QIIME called respectively SOP and MA. SOP correspond to Standard Operating Procedures (program guidelines) whereas MA stands for Multi-Affiliation and correspond to a multiple affiliation strategy used to propagate uncertainty when multiple equally good affiliations are found for a given OTU. This is the default strategy used in FROGS. 

Throughout, QIIME (MA) refers to QIIME with Multi-Affiliation strategy, QIIME (SOP) to the affiliation strategy suggested in QIIME SOP and QIIME to both variants: QIIME (MA) and QIIME (SOP). 

## Metrics used for comparison 

The results of FROGS, MOTHUR and UPARSE, QIIME are compared using three different metrics:   

1. **Divergence**: Bray-Curtis distance (expressed in percent) between the true taxonomic composition of the community and the one inferred by the otu-picking tool. The divergence is measured at all taxonomic ranks from Phylum to either Genus (utax) or Species (Silva).  
2. **FN**: Number of false negative taxa (*i.e.* present in the original bacterial community but not discovered by the otu picking method);
3. **FP**: Number of false positive taxa (*i.e.* discovered by the otu picking method but not present in the original bacterial community)  

## Experimental design

The experimental design differed for the simulated communities (for which a full-factorial design was used) and the synthetic communities. 

### Simulated bacterial communities

The simulated communities were built according to the following design:  

1. **Databank**: Biobank from which taxa were drawn to construct theoretical communities, either Silva (*silva*) or Utax (*utax*).  
2. **Number of OTUs**: 20, 100, 200, 500 and 1000;  
3. **Abundance distribution**: abundances of OTUs were either uniform (*uniform*) or sampled from a power distribution (*power_law*);  
4. **Dataset**: Theoretical communities. Each dataset (5 for each combinaison of abundance distribution and number of OTUs) correspond to a unique **ideal** bacterial community specified by its own taxa set and corresponding vector of relative abundances.  
5. **Set Number**: Biological replicates (10 for each dataset), *i.e.* communities created by sampling organisms with replacement in the theoretical communities.  
6. **Amplicon**: variable region of the 16S rRNA used to produce the ampicon sequences, either the V3-V4 (*V3V4*) variable region or the V4-V4 (*V4V4*) variable region  

This resulted in a total of 2 databanks $\times$ 5 community sizes $\times$ 2 abundance distribution $\times$ 10 theoretical communities $\times$ 10 replicates for each theoretical community $\times$ 2 amplicons $=$ `r 2*5*2*5*10*2` samples (`r 5*2*5*10*2` per databank). 

```{r experimental-design-silva, eval = FALSE}
read.table("silva.tsv", sep = "\t", header = TRUE) %>% group_by(databank, nb_OTU, amplicon, abundance_law, dataset) %>% summarize(count = n()/4) %>% kable()
read.table("utax.tsv", sep = "\t", header = TRUE) %>% group_by(databank, nb_OTU, amplicon, abundance_law, dataset) %>% summarize(count = n()/7) %>% kable()
```

### Synthetic communities

The experimental design used for the synthetic community was sligthly different:
```{r experimental-design-real}
read.table("reel.tsv", sep = "\t", header = TRUE) %>% group_by(nb_OTU, amplicon, abundance_law) %>% summarize(count = n()/4) %>% kable()
```

Three samples corresponding to communities of size 20 with abundance distribution *even* were used to compare the amplicon *V3V4*, *V4V4* and *V4V5* (1 per amplicon). 8 samples corresponding to communities of size 20 and amplicon *V3V4* were used to compared abundance distribution *even* and *staggered* (4 per distribution) and finally, 10 samples (community size 4, amplicon *V3V4* and distribution *even*) were used to compare the accuracy of the different otu picking methods. 


# Statistical analysis of the results: Material and Methods

For each of the three metrics (divergence, FN and FP) we performed two-sided paired test, either parametric (paired t-test) or non-parametric (signed rank test, also known as paired mann-whitney test) to assess the difference in accuracy between FROGS and each of the competitors. 

The tests were peformed at the theoretical community levels (*dataset*) using biological replicates (*set_number*) as replicates. We chose to compare the methods at this level because it the finest one for which we have replication. Pooling different theoretical communities and/or abundance distributions to compare the method at higher levels (*e.g* community size $\times$ amplicon) will blur the signal as a method may be  outclass the others for even abundances but perform worse on different abundance disrtibutions. 

For each theoretical community, we declared FROGS better (resp. worse) than its competitor when the test was significant at the 0.05 level and FROGS had a lower (resp. higher) metric than its competitor. When the test was not significant, the methods were declared tied. Finally, we aggregated the results to count for each condition (community size $\times$ abundance distribution $\times$ amplicon) the number of theoretical communities favoring one or none of the methods. 

Before presenting the statistical analysis per se, we first present the results graphically for each of the databank and for the synthetic communities. 

[//]: # (Import and format data)

```{r data-format, eval = FALSE}
data$nb_OTU <- as.numeric(sub("sp", "", data$nb_OTU))
if ("OTU.lost" %in% names(data)) {
data <- data %>% mutate(OTU.lost = -OTU.lost) %>%
  melt(id.vars = c("databank", "nb_OTU", "dataset", 
                   "set_number", "amplicon", "abundance_law", "method"), 
       value.name = "divergence", 
       variable.name = "rank")
  levels(data$rank) <- c(levels(data$rank)[1:(length(levels(data$rank))-2)], "FN", "FP")
} else {
data <- data %>% 
  melt(id.vars = c("databank", "nb_OTU", "dataset", 
                   "set_number", "amplicon", "abundance_law", "method"), 
       value.name = "divergence", 
       variable.name = "rank")
  
}
data.2 <- data %>% dcast(databank + nb_OTU + dataset + set_number + amplicon + abundance_law + rank ~ method, value.var = "divergence", fun.aggregate = mean) %>% 
  melt(id.vars = c("databank", "nb_OTU", "dataset", 
                   "set_number", "amplicon", "abundance_law", "rank", "frogs"), 
       value.name = "divergence", 
       variable.name = "method")
```

```{r split-divergence-and-otu, eval = FALSE}
data.otus <- filter(data, (rank %in% c("FP", "FN"))) %>% mutate(error_type = rank)
data <- filter(data, !(rank %in% c("FP", "FN"))) %>% mutate(rank = factor(rank))
data.otus.2 <- filter(data.2, (rank %in% c("FP", "FN"))) %>% mutate(error_type = rank)
data.2 <- filter(data.2, !(rank %in% c("FP", "FN"))) %>% mutate(rank = factor(rank))
```

```{r plot-data-raw, message=FALSE, warning=FALSE, eval = FALSE}
p <- ggplot(data = data.2, mapping = aes(x = frogs, y = divergence, color = abundance_law, shape = amplicon)) + facet_grid(rank ~ nb_OTU) + geom_abline(slope = 1, intercept = 0) + theme_bw() + scale_x_log10() + scale_y_log10() + xlab("divergence frogs")
plot.list <- generate_pointplot(p, data = data.2, vbl="method", ylab = "Divergence competitor")
g <- grid_arrange_shared_legend(plot.list, ncol = 2, plot = FALSE)
grid.draw(g)
```

```{r plot-data-raw-boxplot, warning=FALSE, eval = FALSE}
p <- ggplot(data.2, mapping = aes(x = interaction(amplicon, abundance_law), y = frogs - divergence, fill = method, color = method)) + facet_grid(rank ~ nb_OTU, scales = "fixed") + geom_boxplot(outlier.size = 0.8) + geom_boxplot(aes(color = NULL), outlier.color = "transparent") + theme_bw() + scale_y_continuous(limits = c(-15, 3)) + theme(axis.text.x = element_text(angle = 90)) + scale_fill_manual(values = manual.palette) + scale_color_manual(values = manual.palette, guide = "none") + xlab(NULL) + ylab("FROGS excess divergence") + geom_hline(yintercept = 0, col = "grey60")
plot(p)
```

```{r plot-frogs-only-divergence, warning=FALSE, eval = FALSE}
p <- ggplot(filter(data, method == "frogs"), mapping = aes(x = rank, y = divergence, fill = method)) + facet_grid(abundance_law + amplicon ~ nb_OTU, scales = "fixed") + geom_boxplot() + theme_bw() + scale_y_continuous(limits = c(0, 16)) + theme(axis.text.x = element_text(angle = 90)) + scale_fill_manual(values = manual.palette) + xlab(NULL) + ggtitle("Divergence")
plot(p)
```

```{r plot-fp-fn-boxplot, warning=FALSE, message = FALSE, eval = FALSE}
p <- ggplot(data.otus, mapping = aes(x = method, fill = method, y = divergence, alpha = amplicon)) + facet_grid(nb_OTU ~ abundance_law, scales = "free_y") + theme_bw() + scale_y_continuous(limits = c(0, NA)) + theme(axis.text.x = element_text(angle = 90)) + scale_fill_manual(values = manual.palette) + scale_color_manual(values = manual.palette) + scale_alpha_discrete(guide = guide_legend(override.aes = list(fill = "grey10")), range = c(0.2, 0.6)) + ylab(NULL)
p.fn <- p + geom_boxplot(data = filter(data.otus, error_type == "FN")) + ggtitle("False Negative OTUs")
p.fp <- p + geom_boxplot(data = filter(data.otus, error_type == "FP")) + ggtitle("False Positive OTUs")
grid_arrange_shared_legend(p.fp, p.fn, ncol = 2)
```

```{r plot-fp-fn-boxplot-no-mothur, warning=FALSE, message = FALSE, eval = FALSE}
p <- ggplot(data.otus, mapping = aes(x = method, fill = method, y = divergence, alpha = amplicon)) + facet_grid(nb_OTU ~ abundance_law, scales = "free_y") + theme_bw() + scale_y_continuous(limits = c(0, NA)) + theme(axis.text.x = element_text(angle = 90)) + scale_fill_manual(values = manual.palette) + scale_color_manual(values = manual.palette) + scale_alpha_discrete(guide = guide_legend(override.aes = list(fill = "grey10")), range = c(0.2, 0.6)) + ylab(NULL)
excluded.methods <- c("mothur", "mothur_sop", "qiime", "qiime_sop", "mothur (MA)", "mothur (SOP)", "qiime (MA)", "qiime (SOP)")
p.fn <- p + geom_boxplot(data = filter(data.otus, error_type == "FN", !(method %in% excluded.methods))) + ggtitle("False Negative OTUs")
p.fp <- p + geom_boxplot(data = filter(data.otus, error_type == "FP", !(method %in% excluded.methods))) + ggtitle("False Positive OTUs")
g <- grid_arrange_shared_legend(p.fp, p.fn, ncol = 2, plot = FALSE)
grid.draw(g)
```

```{r batch-t-test, eval = FALSE}
data.t.test <- data.2 %>% group_by(databank, nb_OTU, dataset, amplicon, abundance_law, rank, method) %>% 
  summarize(pval = t.test(frogs, divergence, paired = TRUE)$p.value, 
            measure = t.test(frogs, divergence, paired = TRUE)$estimate) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r batch-t-test-plot, eval = FALSE}
p <- ggplot(mapping = aes(x = rank, fill = best)) + facet_grid(abundance_law + amplicon ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette, drop = FALSE) + 
  theme(axis.text.x = element_text(angle = 90), 
        plot.title = element_text(hjust = 0.5))
plot.list <- generate_barplot(p, data = data.t.test, vbl = "method", ylab = "Number of communities")
g <- grid_arrange_shared_legend(plot.list, ncol = 2, plot = FALSE)
grid.draw(g)
```

```{r batch-wilcox-test-np, eval = FALSE}
data.wilcox.test <- data.2 %>% group_by(databank, nb_OTU, dataset, amplicon, abundance_law, rank, method) %>% 
  summarize(pval = wilcox.test(frogs, divergence, paired = TRUE)$p.value, 
            measure = wilcox.test(frogs, divergence, paired = TRUE, conf.int = TRUE)$estimate) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r batch-wilcox-test-plot, eval = FALSE}
p <- ggplot(mapping = aes(x = rank, fill = best)) + facet_grid(abundance_law + amplicon ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90))
plot.list <- generate_barplot(p, data = data.wilcox.test, vbl = "method", ylab = "Number of communities")
g <- grid_arrange_shared_legend(plot.list, ncol = 2, plot = FALSE)
grid.draw(g)
```

```{r batch-t-test-otus, eval = FALSE}
data.otus.t.test <- data.otus.2 %>% group_by(databank, nb_OTU, dataset, amplicon, abundance_law, error_type, method) %>% 
  summarize(pval = my.paired.t.test(frogs, divergence)$p.value, 
            measure = my.paired.t.test(frogs, divergence)$estimate) %>% 
  mutate(best = ifelse(measure > 0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r batch-t-test-otus-plot, eval = FALSE}
p <- ggplot(mapping = aes(x = error_type, fill = best)) + facet_grid(abundance_law + amplicon ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90)) + xlab("Error Type")
plot.list <- generate_barplot(p, data = data.otus.t.test, vbl = "method", ylab = "Number of communities")
g <- grid_arrange_shared_legend(plot.list, ncol = 2, plot = FALSE)
grid.draw(g)
```

```{r batch-wilcox-test-np-otus, warning=FALSE, eval = FALSE}
data.otus.wilcox.test <- data.otus.2 %>% group_by(databank, nb_OTU, dataset, amplicon, abundance_law, error_type, method) %>% 
  summarize(pval = my.paired.wilcox.test(frogs, divergence)$p.value, 
            measure = sum(sign(frogs - divergence) * rank(abs(frogs - divergence)))) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r batch-wilcox-test-plot-otus, eval = FALSE}
p <- ggplot(mapping = aes(x = error_type, fill = best)) + facet_grid(abundance_law + amplicon ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90)) + xlab("Error Type")
plot.list <- generate_barplot(p, data = data.otus.wilcox.test, vbl = "method", ylab = "Number of communities")
g <- grid_arrange_shared_legend(plot.list, ncol = 2, plot = FALSE)
```

[//]: # (End of generic code)

# Utax databank


```{r utax-data-import}
data <- read.table("utax.tsv", sep = "\t", header = TRUE)
```

```{r utax-data-format, ref.label="data-format"}
```

```{r utax-change-method-order}
data <- data %>% mutate(method = factor(method, levels = c("frogs", "uparse_sop", "uparse", "mothur_sop", "mothur", "qiime_sop", "qiime"), 
                                            labels = c("frogs", "uparse (SOP)", "uparse (MA)", "mothur (SOP)", "mothur (MA)", "qiime (SOP)", "qiime (MA)")))
data.2 <- data.2 %>% mutate(method = factor(method, levels = c("uparse_sop", "uparse", "mothur_sop", "mothur", "qiime_sop", "qiime"), 
                                            labels = c("uparse (SOP)", "uparse (MA)", "mothur (SOP)", "mothur (MA)", "qiime (SOP)", "qiime (MA)")))
```

```{r utax-split-divergence-and-otu, ref.label="split-divergence-and-otu"}
```

## Vizualisation 

### Divergence 

The comparisons of divergence at the sample level in the scatterplots shows that on average, FROGS has comparable but better performances than MOTHUR, UPARSE and QIIME (SOP): most samples end up in the upper left corner (corresponding to the region "divergence FROGS < divergence competitor") but no too far away from the first diagonal (grey line). It also has comparable performances to QIIME (MA) but in certain conditions, samples are not mostly contained in the upper left half of the graph, meaning that QIIME (MA) outperforms FROGS for those parameter values. 


```{r utax-plot-data-raw, fig.width=10, fig.height=15, message=FALSE, warning=FALSE, ref.label="plot-data-raw"}
```

A more traditional representation using boxplot of the excess divergence of FROGS, with samples from all theoretical communities pooled together, confirms the results: FROGS has similar (compared to UPARSE) or lower (compared to MOTHUR) divergence for the vast majority of samples. Note that the y-range was reduced from $[-85, 31]$ to $[-15, 3]$ in order to exclude outliers (4% of outliers with excess divergence < -15 and 0.02% with excess divergence > 3) and zoom in on the boxplots. As expected, all methods perform quite similarly up to the order level and the main differences appear at the *Family* and *Genus* levels, where MOTHUR and QIIME (SOP) produces much larger divergences than competing methods. The only configuration where FROGS is consistently outperformed is complex communities (number of species > 200) with uniform abundances and sequenced on the V4V4 region. In that configuration, FROGS is outperformed by QIIME (MA). 

```{r utax-plot-data-raw-boxplot, fig.width=10, fig.height=7, warning=FALSE, ref.label="plot-data-raw-boxplot"}
```

Finally a focus on the accuracy of FROGS alone shows that divergence levels vary between 0 and 10% and as expected, is higher for fine classification (Genus) than for coarse ones (Phylum). Unsurprisingly, the V3V4 amplicon gives less distorded view of communities than the V4V4. Overall, FROGS recover community compositions very well expect at the genus level for complex communities (size > 200), with uniform abundances and sequenced using the V4V4 region. 
```{r utax-plot-frogs-only-divergence, fig.width=10, fig.height=7, warning=FALSE, ref.label="plot-frogs-only-divergence"}
```

### False Positive and False Negative OTUs

We repeat the graphical exploration of the resutls with False Positive and False Negative OTUs. A first representation shows that use of the V3V4 amplicon leads to more false postive and less false negative than the V4V4. The graphics also highlight the gigantic number of false positive inferred by mothur (up to 20 times more than the real community size).  

```{r utax-plot-fp-fn-boxplot, fig.width=10, fig.height=8, warning=FALSE, message = FALSE, ref.label="plot-fp-fn-boxplot"}
```

A focus on FROGS and UPARSE leads to similar patterns: FROGS always produces less false negatives than UPARSE but produces a bit more false positive under power law abundance distribution and a bit less under uniform abundance distribution. 

The lower number of false positive under power law abundances could be due to the abundance based filters used in UPARSE. 

```{r utax-plot-fp-fn-boxplot-no-mothur, fig.width=10, fig.height=8, warning=FALSE, message = FALSE, ref.label="plot-fp-fn-boxplot-no-mothur"}
```

## Statistical Analysis

### Divergence

We present the results of the paired tests, either parametric (t-test, top) or non-parametric (signed rank test, bottom). Both tests show that FROGS perform as well or better as UPARSE and MOTHUR in most conditions. The only condition in which FROGS does worse than UPARSE is small community size (20). It also does better than QIIME (SOP) in all settings, and than QIIME (MA) in most settings with the notable exception of large communities (size > 200) with uniform abundance studied using the V4V4 region. 

The real strength of FROGS lies in its ability ot give a more accurate view of large communities (size > 200) at fine scales (Species or Genus level). 

#### Paired t-test

```{r utax-batch-t-test, ref.label="batch-t-test"}
```

```{r utax-batch-t-test-plot, fig.width=10, fig.height=15, ref.label="batch-t-test-plot"}
```

#### Signed rank test

```{r utax-batch-wilcox-test-np, ref.label="batch-wilcox-test-np"}
```

```{r utax-batch-wilcox-test-plot, fig.width=10, fig.height=15, ref.label="batch-wilcox-test-plot"}
```

### Conditions where QIIME (MA) outperforms FROGS

A focus on the performance of QIIME (MA) reveals that QIIME (MA) indeed performs better than FROGS with uniform distribution when using the V4V4 amplicon region. However and although significant, the differences are small in that case: less than 2 percentage points in all cases and most marked at the Genus level where the divergences of both FROGS and QIIME (MA) are quite high.  

```{r qiime-better-frogs, fig.width=10, fig.height=6, warning=FALSE}
p1 <- ggplot(data.2 %>% filter(method == "qiime (MA)"), 
            mapping = aes(x = rank, y = (frogs - divergence), fill = method)) + 
  facet_grid(amplicon + abundance_law ~ nb_OTU, scales = "free_y") + 
  theme_bw() + scale_y_continuous() + theme(axis.text.x = element_text(angle = 90)) + 
  scale_fill_manual(values = manual.palette, guide = guide_legend(byrow = TRUE)) + scale_color_manual(values = manual.palette, guide = "none") + 
  xlab("Number of OTUs") + ylab("Frogs excess divergence") + 
  geom_boxplot(aes(group = rank), outlier.size = 0.8) + geom_hline(aes(yintercept = 0), color = "gray65")
p2 <- ggplot(data %>% filter(method %in% c("frogs", "qiime (MA)")), 
            mapping = aes(x = rank, y = (divergence), fill = method)) + 
  facet_grid(amplicon + abundance_law ~ nb_OTU, scales = "free_y") + 
  theme_bw() + scale_y_continuous(limits = c(0, 10), breaks = c(0, 3, 6, 9)) + theme(axis.text.x = element_text(angle = 90)) + 
  scale_fill_manual(values = manual.palette, guide = guide_legend(byrow = TRUE)) + scale_color_manual(values = manual.palette, guide = "none") + 
  xlab("Number of OTUs") + ylab("Divergence") + 
  geom_boxplot(aes(group = interaction(rank, method), color = method), outlier.size = 0.8) + 
  geom_boxplot(aes(group = interaction(rank, method)), outlier.color = "transparent")
## grid_arrange_shared_legend(p2, p1, ncol = 2)
grid.arrange(p1 + theme(legend.position = "bottom"), p2 + theme(legend.position = "bottom"), ncol = 2, widths = c(0.45, 0.55))
```

### False Positive and False Negative OTUs

The same paired test as in the previous section reveal that FROGS strictly outperforms MOTHUR in terms of both FP and FN taxas. It also produces less FN than UPARSE. Additionnally, it produces less FP than UPARSE for uniform distributions and more power law ones. Overall, FROGS produces less FP and less FN than either of UPARSE and MOTHUR for high community sizes (>200 for uniform distributions, >1000 for power law distributions). It also produces less FP and FN than QIIME under power law distribution and less FP but more FN than QIIME under uniform distribution. 

#### Paired t-test

```{r utax-batch-t-test-otus, ref.label="batch-t-test-otus"}
```

```{r utax-batch-t-test-otus-plot, fig.width=10, fig.height=15, ref.label="batch-t-test-otus-plot"}
```

#### Signed rank test

```{r utax-batch-wilcox-test-np-otus, warning=FALSE, ref.label="batch-wilcox-test-np-otus"}
```

```{r utax-batch-wilcox-test-plot-otus, fig.width=10, , fig.height=15, ref.label="batch-wilcox-test-plot-otus"}
```


# Silva databank


```{r silva-data-import}
data <- read.table("silva.tsv", sep = "\t", header = TRUE)
```

```{r silva-data-format, ref.label="data-format"}
```

```{r silva-change-method-order}
data <- data %>% mutate(method = factor(method, levels = c("frogs", "uparse", "mothur", "qiime"), 
                                        labels = c("frogs", "uparse (MA)", "mothur (MA)", "qiime (MA)")))
data.2 <- data.2 %>% mutate(method = factor(method, levels = c("uparse", "mothur", "qiime"), 
                                            labels = c("uparse (MA)", "mothur (MA)", "qiime (MA)")))
```

```{r silva-split-divergence-and-otu, ref.label="split-divergence-and-otu"}
```

## Vizualisation 

### Divergence 

The comparisons of divergence at the sample level in the scatterplots shows that on average, FROGS has comparable but better performances than MOTHUR (MA), UPARSE (MA) and QIIME (MA): most samples end up in the upper left corner (corresponding to the region "divergence FROGS < divergence competitor") but no too far away from the first diagonal (grey line). 


```{r silva-plot-data-raw, fig.width=12, fig.height=10, message=FALSE, warning=FALSE, ref.label="plot-data-raw"}
```

A more traditional representation using boxplot of the excess divergence of FROGS, with samples from all theoretical communities pooled together, confirms the results: FROGS has similar (compared to UPARSE (MA) and QIIME (MA)) or lower (compared to MOTHUR (MA)) divergence for the vast majority of samples. Note that the y-range was reduced from $[-51, 41]$ to $[-15, 3]$ in order to exclude from outliers (1% of communities with low FROGS but very high MOTHUR (MA) divergence or high FROGS but low QIIME (MA) divergences) and zoom in on the boxplots. The only configuration where FROGS is consistently outperformed is complex communities (number of species > 200) with uniform abundances and sequenced on the V4V4 region. In that configuration, FROGS is outperformed by QIIME (MA). 

```{r silva-plot-data-raw-boxplot, fig.width=10, fig.height=7, warning=FALSE, ref.label="plot-data-raw-boxplot"}
```

Finally a focus on the accuracy of FROGS alone shows that divergence levels vary mostly between 0 and 15% and as expected, are higher for finer classifications (Species) than for coarse ones (Phylum). Unsurprisingly, the V3V4 amplicon gives less distorded view of communities than the V4V4. 
```{r silva-plot-frogs-only-divergence, fig.width=10, fig.height=7, warning=FALSE, ref.label="plot-frogs-only-divergence"}
```

### False Positive and False Negative OTUs

We repeat the graphical exploration of the resutls with False Positive and False Negative OTUs. A first representation shows that use of the V3V4 amplicon leads to more false postive and less false negative than the V4V4. The graphics also highlight the gigantic number of false positives inferred by MOTHUR and QIIME (up to 20 times more than the real community size).  

```{r silva-plot-fp-fn-boxplot, fig.width=10, fig.height=8, warning=FALSE, message = FALSE, ref.label="plot-fp-fn-boxplot"}
```

A focus on FROGS and UPARSE (MA) leads to similar patterns: FROGS always produces less false negatives than UPARSE (MA) but produces a bit more false positive under power law abundance distribution and a bit less under uniform abundance distribution. 

The lower number of false positive in under power law abundances could be due to the abundance based filters used in UPARSE (MA). 

```{r silva-plot-fp-fn-boxplot-no-mothur, fig.width=10, fig.height=8, warning=FALSE, message = FALSE, ref.label="plot-fp-fn-boxplot-no-mothur"}
```

## Statistical Analysis

### Divergence

We present the results of the paired tests, either parametric (t-test, top) or non-parametric (signed rank test, bottom). Both tests show that FROGS perform as well or better as UPARSE (MA) and MOTHUR (MA) in most conditions. The only condition in which FROGS does worse than UPARSE (MA) is small community size (20). It also does better than QIIME (MA) in most settings, with the exception of large communities (size > 200) with uniform abundance studied using the V4V4 region. 

The real strength of FROGS lies in its ability ot give a more accurate view of large communities (size > 200) at fine scales (Genus level). 

#### Paired t-test

```{r silva-batch-t-test, ref.label="batch-t-test"}
```

```{r silva-batch-t-test-plot, fig.width=10, fig.height=10, ref.label="batch-t-test-plot"}
```

#### Signed rank test

```{r silva-batch-wilcox-test-np, ref.label="batch-wilcox-test-np"}
```

```{r silva-batch-wilcox-test-plot, fig.width=10, fig.height=10, ref.label="batch-wilcox-test-plot"}
```

### False Positive and False Negative OTUs

The same paired test as in the previous section reveal that FROGS strictly outperforms MOTHUR (MA) in terms of both FP and FN taxas. It also produces less FN than UPARSE (MA) and less FP than QIIME (MA). Additionnally, it produces less FP than UPARSE (MA) for uniform distributions and more for power law ones. 

Overall, FROGS produces less FP and less FN than either of UPARSE (MA) and MOTHUR (MA) for high community sizes (>200 for uniform distributions, >1000 for power law distributions) and less FP than QIIME (MA) at all sizes. 

#### Paired t-test

```{r silva-batch-t-test-otus, ref.label="batch-t-test-otus"}
```

```{r silva-batch-t-test-otus-plot, fig.width=10, fig.height=10, ref.label="batch-t-test-otus-plot"}
```

#### Signed rank test

```{r silva-batch-wilcox-test-np-otus, warning=FALSE, ref.label="batch-wilcox-test-np-otus"}
```

```{r silva-batch-wilcox-test-plot-otus, fig.width=10, fig.height=10, ref.label="batch-wilcox-test-plot-otus"}
```

# Synthetic Communities (I)

Due to the different design used for synthetic communities, we're going to perform focused comparisons of the samples. 

```{r real-data-import}
data <- read.table("reel.tsv", sep = "\t", header = TRUE)
```

```{r real-data-format, ref.label="data-format"}
```

```{r real-change-method-order}
data <- data %>% mutate(method = factor(method, levels = c("frogs", "uparse", "mothur", "qiime"), 
                                        labels = c("frogs", "uparse (SOP)", "mothur (SOP)", "qiime (SOP)")))
data.2 <- data.2 %>% mutate(method = factor(method, levels = c("uparse", "mothur", "qiime"), 
                                            labels = c("uparse (SOP)", "mothur (SOP)", "qiime (SOP)")))
```

## Amplicon Effect 

We study the amplicon effect on the even community with 20 species as it is the only one for which different amplicons were used. We represent the trends observed at different taxonomic levels. All methods seem to give comparable results but there are no replicates per amplicon so we can't assess the significance of the observed differences. 

Note that all methods have high divergences compared to simulated datasets. This may reflect experimental limitations (sequencing and amplification bias, copy number variations, etc) rather than intrinsic complexity of the synthetic community and/or differences between the methods. 

```{r amplicon-effect-paired-plot}
p <- ggplot(filter(data, abundance_law == "even" & set_number == "set1"), aes(x = method, y = divergence)) + geom_point(aes(color = method)) + geom_line(aes(group = rank, alpha = rank)) + facet_grid(~amplicon) + scale_color_manual(values = manual.palette) + scale_y_continuous(lim = c(0, NA)) + theme_bw() + theme(axis.text.x = element_text(angle = 90))
plot(p)
```

## Abundance Distribution Effect

We study the abundance distribution effect on the community with 20 species sequenced with the V3V4 amplicon region. FROGS is better than MOTHUR (MA), UPARSE (MA) and QIIME (MA) on the staggered community and worse on the even one... 

```{r distribution-effect-paired-plot, fig.width = 8, fig.height = 4.5}
p <- ggplot(filter(data.2, amplicon == "V3V4" & nb_OTU == 20), aes(x = method, y = frogs - divergence)) + geom_point() + geom_boxplot(aes(fill = method)) + facet_grid(abundance_law ~ rank) + scale_color_manual(name = "Competitor", values = manual.palette) + scale_fill_manual(name = "Competitor", values = manual.palette) + theme_bw() + geom_hline(yintercept = 0, col = "grey60") + ylab("Frogs excess divergence") + theme(axis.text.x = element_text(angle = 90))
plot(p)
```

Although the base divergence is not very satisfying on either distribution. 
```{r distribution-effect-boxplot, fig.width = 8, fig.height = 4.5}
p <- ggplot(filter(data, amplicon == "V3V4", nb_OTU == 20, method == "frogs"), aes(x = method, y = divergence)) + geom_point() + geom_boxplot(aes(fill = method)) + facet_grid(abundance_law ~ rank) + scale_color_manual(values = manual.palette) + scale_fill_manual(values = manual.palette) + theme_bw() + ylab("Frogs divergence") + theme(axis.text.x = element_text(angle = 90))
plot(p)
```

As we have 4 replicates for this community, we can compare all methods using a paired t-test (there are not enough replicates for the non parametric signed rank test to reach significance). The statistical analysis confirm that FROGS outperforms MOTHUR (MA), UPARSE (MA) and QIIME (MA) on communities with staggered abundances but does worse on communities with even abundances. 

```{r real-distribution-t-test}
data.t.test <- data.2 %>% filter(amplicon == "V3V4", nb_OTU == 20) %>% 
  group_by(databank, nb_OTU, dataset, amplicon, abundance_law, rank, method) %>% 
  summarize(pval = t.test(frogs, divergence, paired = TRUE)$p.value, 
            measure = t.test(frogs, divergence, paired = TRUE)$estimate) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r real-distribution-t-test-plot, fig.width=8, fig.height=8}
p <- ggplot(mapping = aes(x = rank, fill = best)) + facet_grid(abundance_law ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90))
plot.list <- generate_barplot(p, data = data.t.test, vbl = "method", ylab = "Number of communities")
g <- grid_arrange_shared_legend(plot.list, ncol = 2, plot = FALSE)
grid.draw(g)
```

## Classification of OTUs

In addition to divergence, we blasted our reconstructed OTUs against the corresponding regions of the 16S rRNA sequences of the 20 species used in the mock. The OTUs were classified into 3 classes according to their blast results:

- *true otu* is the cluster seed had 100% identity and 100% coverage with one of the 20 species 16S rRNA
- *accepted otu* if the seed had >97 identity over >95% coverage
- *spurious otu* if the seed had <97% identity

For each category, we counted both (i) the number of reconstructed OTUs in that category (middle panel: OTU) and (ii) their aggregate contribution to the community (top panel: Abundancy). 

We also blasted the 20 16S rRNA sequences that were supposed to be recovered against the recovered OTU to find how many were really missed, as opposed to reconstructed as a slightly erroneous OTU. Again, the retrieved sequences were classified in 3 categories according to their blast results

- *retrieved as true (true)* if the sequence had 100% identity against one of the cluster seed
- *retrieved as accepted (accepted)* if it had <100% and >97% sequence identity
- *not retrieved (not)* otherwise

The number of species of the in each category are shown in the bottom panel (Retrieved). 

```{r load-additional-data}
add.data <- read.table("reel-2.tsv", sep = "\t", header = TRUE) %>% select(-one_of("Genus", "Family", "Order", "Class", "Phylum")) %>% mutate(nb_OTU = as.numeric(sub("sp", "", nb_OTU)))
```

### Amplicon Effect

As previously shown, the bulk of reads fall in true or accepted OTUs. UPARSE produces the less OTUs but also misses more OTU than competing methods. Both QIIME and MOTHUR produce enormous amounts of spurious OTUs. All methods fail to recover true otus on the V4V5 regions. 

```{r format-amplicon-table}
id <- c("databank", "nb_OTU", "dataset", "set_number", "amplicon", "abundance_law", "method")
var_set_1 <- c("nb_true_OTU", "nb_accepted_true_OTU", "nb_spurious_otu")
var_set_2 <- c("abundancy_true_OTU", "abundancy_accepted_OTU", "abundancy_spurious_OTU")
var_set_3 <- c("nb_retrieved_species", "nb_accepted_retrieved_species", "nb_not_retrieved_species")
## select amplicon data
amplicon.data <- add.data %>% filter(set_number == "set1", abundance_law == "even")
## format nb OTU
d1 <- amplicon.data %>% select(one_of(c(id, var_set_1))) %>%
  melt(id.vars = id, value.name = "value", variable.name = "OTU_type") %>% mutate(Value_type = "OTU") %>%
  mutate(OTU_type = setNames(c("true", "accepted", "spurious"),
                             var_set_1)[OTU_type])
## format abundancies
d2 <- amplicon.data %>% select(one_of(c(id, var_set_2))) %>%
  melt(id.vars = id, value.name = "value", variable.name = "OTU_type") %>% mutate(Value_type = "Abundancy") %>%
  mutate(OTU_type = setNames(c("true", "accepted", "spurious"),
                             c(var_set_2))[OTU_type]) %>% 
  group_by_at(vars(one_of(id))) %>% 
  mutate(value = 100 * value / sum(value))
## format retrieved species
d3 <- amplicon.data %>% select(one_of(c(id, var_set_3))) %>% 
  mutate(nb_not_retrieved_species = 20 - nb_retrieved_species - nb_accepted_retrieved_species) %>%
  melt(id.vars = id, value.name = "value", variable.name = "OTU_type") %>% mutate(Value_type = "Retrieved") %>%
  mutate(OTU_type = setNames(c("true", "accepted", "not"),
                             c(var_set_3))[OTU_type])
## merge everything
amplicon.data <- bind_rows(d1, d2, d3) %>% 
  mutate(OTU_type = factor(OTU_type, levels = c("not", "spurious", "accepted", "true")), 
         method = factor(method, levels = c("frogs", "uparse", "mothur", "qiime"), 
                         labels = c("frogs", "uparse (SOP)", "mothur (SOP)", "qiime (SOP)"))) 

```

```{r show-amplicon-table-full, fig.width = 7, fig.height=4.5}
p <- ggplot(amplicon.data, aes(x = method, y = value, fill = OTU_type)) + 
  geom_bar(stat = "identity", position = "stack", color = "black") + 
  facet_grid(Value_type ~ amplicon, scale = "free_y") + 
  ## scale_fill_manual(values = manual.palette) + 
  ## scale_alpha_manual(values = setNames(c(0, 0.2, 0.6, 1), c("not", "spurious", "accepted", "true"))) +
  scale_fill_manual(values = setNames(c("white", "grey70", "grey40", "grey10"), c("not", "spurious", "accepted", "true"))) +
  theme_bw() + labs(x = NULL, y = NULL) + 
  theme(axis.text.x = element_text(angle = 90))
plot(p)
```

A focus on FROGS and UPARSE reveals the same trend at a lower scale. 

```{r show-amplicon-table-uparse, fig.width = 4.5, fig.height=4.5}
p <- ggplot(amplicon.data %>% filter(method %in% c("frogs", "uparse (SOP)")), 
            aes(x = method, y = value, fill = OTU_type)) + 
  geom_bar(stat = "identity", position = "stack", color = "black") + 
  facet_grid(Value_type ~ amplicon, scale = "free_y") + 
  ## scale_fill_manual(values = manual.palette) + 
  ## scale_alpha_manual(values = setNames(c(0, 0.2, 0.6, 1), c("not", "spurious", "accepted", "true"))) +
  scale_fill_manual(values = setNames(c("white", "grey70", "grey40", "grey10"), c("not", "spurious", "accepted", "true"))) +
  theme_bw() + labs(x = NULL, y = NULL) + 
  theme(axis.text.x = element_text(angle = 90))
plot(p)
```

### Distribution Effect

As previously shown, the bulk of reads fall in true or accepted OTUs. UPARSE produces the less spurious OTUs but also misses more OTU than competing methods, especially with a staggered abundance. Both QIIME and UPARSE produce enormous amounts of spurious OTUs.

```{r format-abundance-table}
id <- c("databank", "nb_OTU", "dataset", "set_number", "amplicon", "abundance_law", "method")
var_set_1 <- c("nb_true_OTU", "nb_accepted_true_OTU", "nb_spurious_otu")
var_set_2 <- c("abundancy_true_OTU", "abundancy_accepted_OTU", "abundancy_spurious_OTU")
var_set_3 <- c("nb_retrieved_species", "nb_accepted_retrieved_species", "nb_not_retrieved_species")
## select amplicon data
abundance.data <- add.data %>% filter(amplicon == "V3V4")
## format nb OTU
d1 <- abundance.data %>% select(one_of(c(id, var_set_1))) %>%
  melt(id.vars = id, value.name = "value", variable.name = "OTU_type") %>% mutate(Value_type = "OTU") %>%
  mutate(OTU_type = setNames(c("true", "accepted", "spurious"),
                             var_set_1)[OTU_type])
## format abundancies
d2 <- abundance.data %>% select(one_of(c(id, var_set_2))) %>%
  melt(id.vars = id, value.name = "value", variable.name = "OTU_type") %>% mutate(Value_type = "Abundancy") %>%
  mutate(OTU_type = setNames(c("true", "accepted", "spurious"),
                             c(var_set_2))[OTU_type]) %>% 
  group_by_at(vars(one_of(id))) %>% 
  mutate(value = 100 * value / sum(value))
## format retrieved species
d3 <- abundance.data %>% select(one_of(c(id, var_set_3))) %>%
  mutate(nb_not_retrieved_species = 20 - nb_retrieved_species - nb_accepted_retrieved_species) %>%
  melt(id.vars = id, value.name = "value", variable.name = "OTU_type") %>% mutate(Value_type = "Retrieved") %>%
  mutate(OTU_type = setNames(c("true", "accepted", "not"),
                             c(var_set_3))[OTU_type])
## merge everything
abundance.data <- bind_rows(d1, d2, d3) %>% 
  mutate(OTU_type = factor(OTU_type, levels = c("not", "spurious", "accepted", "true")), 
         method = factor(method, levels = c("frogs", "uparse", "mothur", "qiime"), 
                         labels = c("frogs", "uparse (SOP)", "mothur (SOP)", "qiime (SOP)"))) 

```

```{r show-abundance-table-full, fig.width = 10, fig.height=4.5}
p <- ggplot(abundance.data, aes(x = method, y = value, fill = OTU_type)) + 
  geom_bar(stat = "identity", position = "stack", color = "black") + 
  facet_grid(Value_type ~ abundance_law + set_number, scale = "free_y") + 
  ## scale_fill_manual(values = manual.palette) + 
  ## scale_alpha_manual(values = setNames(c(0, 0.2, 0.6, 1), c("not", "spurious", "accepted", "true"))) +
  scale_fill_manual(values = setNames(c("white", "grey70", "grey40", "grey10"), c("not", "spurious", "accepted", "true"))) +
  theme_bw() + labs(x = NULL, y = NULL) + 
  theme(axis.text.x = element_text(angle = 90))
plot(p)
```

A focus on FROGS and UPARSE reveals the same trend at a different scale. Both FROGS and UPARSE sort most of the read into true OTUs. FROGS always finds back a few more OTUs than UPARSE, misses a few less and produces less spurious otus. The most important difference is in terms of accepted OTUs where FROGS systematically produces more accepted OTUs than UPARSE. 

Note that, by the very nature of UPARSE algorithm, if one of the 20 sequences in recovered as a true OTU, there can be no accepted OTU for that OTU as they would be clustered together with the true OTU. It's both a feature, when the sequences are well grouped at the 97% sequence identity threshold, and a limitation, if two population with less than 3% divergence are present simultaneously, they can't be recovered by UPARSE but can by FROGS, thanks to its reliance on SWARM. 

```{r show-abundance-table-uparse, fig.width = 8, fig.height=4.5}
p <- ggplot(abundance.data %>% filter(method %in% c("frogs", "uparse (SOP)")), 
            aes(x = method, y = value, fill = OTU_type)) + 
  geom_bar(stat = "identity", position = "stack", color = "black") + 
  facet_grid(Value_type ~ abundance_law + set_number, scale = "free_y") + 
  ## scale_fill_manual(values = manual.palette) + 
  ## scale_alpha_manual(values = setNames(c(0, 0.2, 0.6, 1), c("not", "spurious", "accepted", "true"))) +
  scale_fill_manual(values = setNames(c("white", "grey60", "grey30", "grey10"), c("not", "spurious", "accepted", "true"))) +
  theme_bw() + labs(x = NULL, y = NULL) + 
  theme(axis.text.x = element_text(angle = 90))
plot(p)
```

## Comparison on a Toy Community

Finally, we compare the 3 methods on a toy community with 4 species and uneven abundances. We have  10 replicates for this community, enough to use either the signed rank test and the paired t-test. Once again FROGS base divergence level is not fantastic
```{r real-method-effect-4-species-boxplot, fig.width = 8, fig.height = 4}
p <- ggplot(filter(data, nb_OTU == 4, method == "frogs"), aes(x = method, y = divergence)) + geom_point(aes(color = method)) + geom_boxplot(aes(fill = method)) + facet_grid(~rank) + scale_color_manual(values = manual.palette) + scale_fill_manual(values = manual.palette) + scale_y_continuous(lim = c(0, NA)) + theme_bw()
plot(p)
```

but in line with divergences obtained by competitors
```{r real-method-effect-4-species-paired-plot, fig.width = 8, fig.height = 4}
p <- ggplot(filter(data.2, nb_OTU == 4), aes(x = method, y = frogs - divergence)) + geom_point() + geom_boxplot(aes(fill = method)) + facet_grid(~ rank) + scale_color_manual(name = "Competitor", values = manual.palette) + scale_fill_manual(name = "Competitor", values = manual.palette) + theme_bw() + geom_hline(yintercept = 0, col = "grey60") + ylab("Frogs excess divergence") + theme(axis.text.x = element_blank())
plot(p)
```

The statistical analyses confirms the graphical diagnostic of the boxplot: FROGS is generally better than MOTHUR (MA) and QIIME (MA) and tied with UPARSE (MA), except at the Genus rank where it outperforms all three. It also performs worse than UPARSE (MA) at the Phylum rank (for the paired t-test)

## Paired t-test on divergence

```{r real-method-t-test-4-species, fig.width=8, fig.height=8}
data.t.test <- data.2 %>% filter(nb_OTU == 4) %>% 
  group_by(databank, nb_OTU, dataset, amplicon, abundance_law, rank, method) %>% 
  summarize(pval = t.test(frogs, divergence, paired = TRUE)$p.value, 
            measure = t.test(frogs, divergence, paired = TRUE)$estimate) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r real-method-t-test-4-species-plot, fig.width=8, fig.height=8}
p <- ggplot(mapping = aes(x = rank, fill = best)) + facet_grid(abundance_law ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90))
plot.list <- generate_barplot(p, data = data.t.test, vbl = "method", ylab = "Number of communities")
g <- grid_arrange_shared_legend(plot.list, ncol = 2, plot = FALSE)
grid.draw(g)
```

## Signed rank test on divergence

```{r real-method-wilcox-test-4-species}
data.wilcox.test <- data.2 %>% filter(nb_OTU == 4) %>% 
  group_by(databank, nb_OTU, dataset, amplicon, abundance_law, rank, method) %>% 
  summarize(pval = wilcox.test(frogs, divergence, paired = TRUE)$p.value, 
            measure = wilcox.test(frogs, divergence, paired = TRUE, conf.int = TRUE)$estimate) %>% 
  mutate(best = ifelse(measure >0, "competitor", "frogs")) %>% 
  mutate(best = ifelse(pval < 0.05, best, "tied")) %>%
  mutate(best = factor(best, levels = c("frogs", "tied", "competitor")))
```

```{r real-method-wilcox-test-4-species-plot, fig.width=8, fig.height=8}
p <- ggplot(mapping = aes(x = rank, fill = best)) + facet_grid(abundance_law ~ nb_OTU) + theme_bw() + scale_fill_manual(values = manual.palette) + theme(axis.text.x = element_text(angle = 90))
plot.list <- generate_barplot(p, data = data.wilcox.test, vbl = "method", ylab = "Number of communities")
g <- grid_arrange_shared_legend(plot.list, ncol = 2, plot = FALSE)
grid.draw(g)
```

# Synthetic Communities (II): Bokulich Datasets

We compare the methods on Bokulich datasets: it consists of three experiments where a synthetic community (mock 6 to 8) made of 67 species was sequenced three times each. Mock 6 to 8 are biological replicates of the same community and the three samples for each mock are technical replicates. Since, we only have three replicates for each mock, we can not use non-parametric signed-rank tests and restrict ourselves to paired t-tests. 

```{r bok-data-import}
data <- read.table("bokulich678.tsv", sep = "\t", header = TRUE)
```

```{r bok-data-format, ref.label="data-format"}
```

```{r bok-change-method-order}
data <- data %>% mutate(method = factor(method, levels = c("frogs", "uparse", "mothur", "qiime"), 
                                        labels = c("frogs", "uparse (SOP)", "mothur (SOP)", "qiime (SOP)")))
data.2 <- data.2 %>% mutate(method = factor(method, levels = c("uparse", "mothur", "qiime"), 
                                            labels = c("uparse (SOP)", "mothur (SOP)", "qiime (SOP)"))) ## %>% 
  ## mutate(dataset = "mock6") ## Consider all datasets as identical
```


## Vizualisation 

### Divergence 

All methods achieve comparable and quite high divergences at low taxonomic ranks (_e.g._ Genus and Family) and smaller ones at high ranks (_e.g._ Phylum). This is again probably a consequence of the real composition being quite different from the manufacturer provided one as a result of library preparation and other sources of biological biases. 

We can however note that FROGS and UPARSE achieve lower divergence than the others at the Genus level. 

```{r bok-divergence-boxplot, fig.width = 8, fig.height = 4.5}
p <- ggplot(filter(data, amplicon == "V4"), aes(x = method, y = divergence)) + geom_point() + geom_boxplot(aes(fill = method)) + facet_grid(abundance_law ~ rank) + scale_color_manual(values = manual.palette) + scale_fill_manual(values = manual.palette) + theme_bw() + ylab("Divergence") + theme(axis.text.x = element_text(angle = 90))
plot(p)
```

The finer view provided by comparing FROGS excess divergence over competing methods shows that it is slightly worse than UPARSE at all ranks, comparable to MOTHUR and QIIME at high taxonomic ranks and strictly better at low taxonomic ranks. 

```{r bok-excess-divergence-boxplot, fig.width = 8, fig.height = 4.5}
p <- ggplot(data.2, aes(x = method, y = frogs - divergence)) + geom_point() + geom_boxplot(aes(fill = method)) + facet_grid(abundance_law ~ rank) + scale_color_manual(values = manual.palette) + 
              scale_fill_manual(values = manual.palette) + theme_bw() + ylab("Frogs ExcessDivergence") + 
              theme(axis.text.x = element_text(angle = 90)) + geom_hline(yintercept = 0)
plot(p)
```

## Statistical Analysis

### Divergence 

#### Paired t-test

```{r bok-batch-t-test, ref.label="batch-t-test", warning= FALSE}
```

```{r bok-batch-t-test-plot, fig.width=10, fig.height=10, ref.label="batch-t-test-plot", warning= FALSE}
```

